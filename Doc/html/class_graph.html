<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRUP_25_T2: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRUP_25_T2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="graph_8h_source.html">graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_graph_1_1_edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_graph_1_1_node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a90961be426ad80001cbc103b6385df31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a90961be426ad80001cbc103b6385df31">Graph</a> ()=default</td></tr>
<tr class="separator:a90961be426ad80001cbc103b6385df31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b4f6dec368300991b68dd75e39a5e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a18b4f6dec368300991b68dd75e39a5e9">Graph</a> (int nodes, bool dir=false)</td></tr>
<tr class="separator:a18b4f6dec368300991b68dd75e39a5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03925cc9ddf22fe4a35d4b17b19376c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a03925cc9ddf22fe4a35d4b17b19376c3">addEdge</a> (int src, int dest, <a class="el" href="struct_line.html">Line</a> line, bool lineDirection, int weight)</td></tr>
<tr class="separator:a03925cc9ddf22fe4a35d4b17b19376c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976e274acb7b585e3ca868276a5b59a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_graph_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a976e274acb7b585e3ca868276a5b59a4">getNode</a> (int index)</td></tr>
<tr class="separator:a976e274acb7b585e3ca868276a5b59a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4236d34420bd8de99385b504c126084e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a4236d34420bd8de99385b504c126084e">addNode</a> (int index, <a class="el" href="struct_stop.html">Stop</a> &amp;stop)</td></tr>
<tr class="separator:a4236d34420bd8de99385b504c126084e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95f8e89fed5083645613ae58288a3c8"><td class="memItemLeft" align="right" valign="top">list&lt; <a class="el" href="struct_graph_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa95f8e89fed5083645613ae58288a3c8">dijkstra_path</a> (int a, int b)</td></tr>
<tr class="separator:aa95f8e89fed5083645613ae58288a3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a75a704f5bebdc893cc94e04b78d410"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a0a75a704f5bebdc893cc94e04b78d410">bfsDist</a> (int v)</td></tr>
<tr class="separator:a0a75a704f5bebdc893cc94e04b78d410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d5ce48a79023ec01e7c5f499ee0a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a98d5ce48a79023ec01e7c5f499ee0a47">dijkstra_distance</a> (int a)</td></tr>
<tr class="separator:a98d5ce48a79023ec01e7c5f499ee0a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d6ac40bc09c63bdf0adb0e312ebc8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa9d6ac40bc09c63bdf0adb0e312ebc8e">dijkstra_zones</a> (int a)</td></tr>
<tr class="separator:aa9d6ac40bc09c63bdf0adb0e312ebc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04e1fea673dbaffcb38f72f9d8d75d9"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ac04e1fea673dbaffcb38f72f9d8d75d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_graph.html#ac04e1fea673dbaffcb38f72f9d8d75d9">dijkstra</a> (int s, Functor &amp;functor)</td></tr>
<tr class="separator:ac04e1fea673dbaffcb38f72f9d8d75d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00142af6bf0fe8a79258e9c3c958bf7c"><td class="memItemLeft" align="right" valign="top">list&lt; <a class="el" href="struct_graph_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a00142af6bf0fe8a79258e9c3c958bf7c">bfs_path</a> (int a, int b)</td></tr>
<tr class="separator:a00142af6bf0fe8a79258e9c3c958bf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75919a65847d850bbe8d5899fc80efc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab75919a65847d850bbe8d5899fc80efc">findLinePath</a> (<a class="el" href="struct_line.html">Line</a> &amp;currentLine, <a class="el" href="struct_graph_1_1_edge.html">Edge</a> &amp;edge)</td></tr>
<tr class="separator:ab75919a65847d850bbe8d5899fc80efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6106304a6e40b60f39efd481f49f06f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab6106304a6e40b60f39efd481f49f06f">addGeoStartEndNode</a> (<a class="el" href="struct_location.html">Location</a> start, <a class="el" href="struct_location.html">Location</a> end, int radius)</td></tr>
<tr class="separator:ab6106304a6e40b60f39efd481f49f06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6514d5f7b5a5bb156c179e9d7c0c565b"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a6514d5f7b5a5bb156c179e9d7c0c565b">nodesInReach</a> (<a class="el" href="struct_location.html">Location</a> pos, int radius)</td></tr>
<tr class="separator:a6514d5f7b5a5bb156c179e9d7c0c565b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a81a76a428e630453ef019a15b9092967"><td class="memItemLeft" align="right" valign="top"><a id="a81a76a428e630453ef019a15b9092967" name="a81a76a428e630453ef019a15b9092967"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>n</b></td></tr>
<tr class="separator:a81a76a428e630453ef019a15b9092967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60baa846929049c84b7e50ffb5f401e8"><td class="memItemLeft" align="right" valign="top"><a id="a60baa846929049c84b7e50ffb5f401e8" name="a60baa846929049c84b7e50ffb5f401e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasDir</b></td></tr>
<tr class="separator:a60baa846929049c84b7e50ffb5f401e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b5e16eb9e0670fea3ecee3526abb41"><td class="memItemLeft" align="right" valign="top"><a id="a71b5e16eb9e0670fea3ecee3526abb41" name="a71b5e16eb9e0670fea3ecee3526abb41"></a>
vector&lt; <a class="el" href="struct_graph_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nodes</b></td></tr>
<tr class="separator:a71b5e16eb9e0670fea3ecee3526abb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><a class="el" href="class_graph.html">Graph</a> structure: composed of nodes linked by edges </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a90961be426ad80001cbc103b6385df31" name="a90961be426ad80001cbc103b6385df31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90961be426ad80001cbc103b6385df31">&#9670;&nbsp;</a></span>Graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Default constructor </p>

</div>
</div>
<a id="a18b4f6dec368300991b68dd75e39a5e9" name="a18b4f6dec368300991b68dd75e39a5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b4f6dec368300991b68dd75e39a5e9">&#9670;&nbsp;</a></span>Graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dir</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a graph with N nodes and if there is a direction to their edges </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>number of nodes to be built </td></tr>
    <tr><td class="paramname">dir</td><td>boolean if edge direction exists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a03925cc9ddf22fe4a35d4b17b19376c3" name="a03925cc9ddf22fe4a35d4b17b19376c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03925cc9ddf22fe4a35d4b17b19376c3">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_line.html">Line</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lineDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds an edge between two nodes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>start node to be linked </td></tr>
    <tr><td class="paramname">dest</td><td>end node to be linked </td></tr>
    <tr><td class="paramname">line</td><td>bus line that makes the edge </td></tr>
    <tr><td class="paramname">lineDirection</td><td>edge direction </td></tr>
    <tr><td class="paramname">weight</td><td>weight of the edge (it can represent multiple things) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6106304a6e40b60f39efd481f49f06f" name="ab6106304a6e40b60f39efd481f49f06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6106304a6e40b60f39efd481f49f06f">&#9670;&nbsp;</a></span>addGeoStartEndNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addGeoStartEndNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_location.html">Location</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_location.html">Location</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds a start and end nodes position and links them to the bus stops inside a certain geographic radius from them </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>location of the start node/position </td></tr>
    <tr><td class="paramname">end</td><td>location of the end node/position </td></tr>
    <tr><td class="paramname">radius</td><td>radius where to search from the start/end node for bus stops to add new walking edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4236d34420bd8de99385b504c126084e" name="a4236d34420bd8de99385b504c126084e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4236d34420bd8de99385b504c126084e">&#9670;&nbsp;</a></span>addNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_stop.html">Stop</a> &amp;&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds a node to an index </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index where to add the node in the graph </td></tr>
    <tr><td class="paramname">stop</td><td>main value of a node is the bus stop it represents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00142af6bf0fe8a79258e9c3c958bf7c" name="a00142af6bf0fe8a79258e9c3c958bf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00142af6bf0fe8a79258e9c3c958bf7c">&#9670;&nbsp;</a></span>bfs_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt; <a class="el" href="struct_graph_1_1_edge.html">Edge</a> &gt; Graph::bfs_path </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the path that BFS algorithm follows to traverse from node A to B with minimum nodal distance </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a0a75a704f5bebdc893cc94e04b78d410" name="a0a75a704f5bebdc893cc94e04b78d410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a75a704f5bebdc893cc94e04b78d410">&#9670;&nbsp;</a></span>bfsDist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::bfsDist </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the nodes dist attribute to their relative nodal distance to the start node (dist = 0) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>start node to consider as dist = 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac04e1fea673dbaffcb38f72f9d8d75d9" name="ac04e1fea673dbaffcb38f72f9d8d75d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04e1fea673dbaffcb38f72f9d8d75d9">&#9670;&nbsp;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dijkstra </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Dijkstra algorithm finds shortest paths and sets the nodes dist based on the distance they are from the starting node taking into account edge weight. Time complexity equals to the dijkstra algorithm, functor is O(1).{\displaystyle O(E+V\log(V))} </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functor</td><td>weight function calculator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>node where to start dijkstra algorithm </td></tr>
    <tr><td class="paramname">functor</td><td>function that calculates dijkstra's edge and node cost distance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98d5ce48a79023ec01e7c5f499ee0a47" name="a98d5ce48a79023ec01e7c5f499ee0a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d5ce48a79023ec01e7c5f499ee0a47">&#9670;&nbsp;</a></span>dijkstra_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dijkstra_distance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the nodes weight and dist values to the geographic distance they are from the node A, based on the edges weights </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>dijkstra algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa95f8e89fed5083645613ae58288a3c8" name="aa95f8e89fed5083645613ae58288a3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95f8e89fed5083645613ae58288a3c8">&#9670;&nbsp;</a></span>dijkstra_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt; <a class="el" href="struct_graph_1_1_edge.html">Edge</a> &gt; Graph::dijkstra_path </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a edge path between the nodes A and B. O(n) n being the size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>start node </td></tr>
    <tr><td class="paramname">b</td><td>end node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>edge path to be taken to reach B starting at A </dd></dl>

</div>
</div>
<a id="aa9d6ac40bc09c63bdf0adb0e312ebc8e" name="aa9d6ac40bc09c63bdf0adb0e312ebc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d6ac40bc09c63bdf0adb0e312ebc8e">&#9670;&nbsp;</a></span>dijkstra_zones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dijkstra_zones </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the nodes weight and dist values based on the weights of the edges which, in this case, have weight &gt;0 if they connect 2 different bus zones </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>node where to start the dijkstra algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab75919a65847d850bbe8d5899fc80efc" name="ab75919a65847d850bbe8d5899fc80efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75919a65847d850bbe8d5899fc80efc">&#9670;&nbsp;</a></span>findLinePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::findLinePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_line.html">Line</a> &amp;&#160;</td>
          <td class="paramname"><em>currentLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_graph_1_1_edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a current bus line and an edge, it attempts to find an edge connecting the same nodes but maintaining the same bus line </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentLine</td><td>current bus line being used </td></tr>
    <tr><td class="paramname">edge</td><td>edge connecting two bus stops </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a976e274acb7b585e3ca868276a5b59a4" name="a976e274acb7b585e3ca868276a5b59a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976e274acb7b585e3ca868276a5b59a4">&#9670;&nbsp;</a></span>getNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_graph_1_1_node.html">Node</a> &amp; Graph::getNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a reference to a graph node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index of the node to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the node stored with the given index </dd></dl>

</div>
</div>
<a id="a6514d5f7b5a5bb156c179e9d7c0c565b" name="a6514d5f7b5a5bb156c179e9d7c0c565b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6514d5f7b5a5bb156c179e9d7c0c565b">&#9670;&nbsp;</a></span>nodesInReach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Graph::nodesInReach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_location.html">Location</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns all nodes inside a certain radius from a position. O(n), n being the number of nodes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position center where to search </td></tr>
    <tr><td class="paramname">radius</td><td>radius of the circle to create and boundary search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with all nodes' indexes that are inside the radius </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="graph_8h_source.html">graph.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
